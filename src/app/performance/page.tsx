"use client";

import { useEffect, useState } from "react";
import { SignalTable, Signal } from "@/components/SignalTable";
// import { PerformanceStats } from "@/components/PerformanceStats";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { PerformanceSummary } from "@/components/PerformanceSummary";
import nextDynamic from "next/dynamic";

const PerformanceStats = nextDynamic(() => import("@/components/PerformanceStats").then(mod => mod.PerformanceStats), {
    ssr: false,
    loading: () => <div className="h-64 flex items-center justify-center bg-muted/10 rounded-2xl animate-pulse">Loading chart...</div>
});

export const dynamic = "force-dynamic";

export default function PerformancePage() {
    const [signals, setSignals] = useState<Signal[]>([]);
    const [loading, setLoading] = useState(true);
    const [activeChannel, setActiveChannel] = useState<string>("Fence - Aurora");

    useEffect(() => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000); // 8s timeout

        async function fetchSignals() {
            try {
                const res = await fetch("/api/signals", { signal: controller.signal });
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);

                const data = await res.json();
                if (Array.isArray(data)) {
                    // Global Date Filter: Only signals from Jan 12, 2026 onwards
                    const recentSignals = data.filter((s: Signal) => s.timestamp >= "2026-01-12");
                    setSignals(recentSignals);
                } else {
                    console.error("Data is not an array:", data);
                }
            } catch (error) {
                if (error instanceof Error && error.name === 'AbortError') {
                    console.error("Fetch request timed out");
                } else {
                    console.error("Failed to fetch signals:", error);
                }
            } finally {
                clearTimeout(timeoutId);
                setLoading(false);
            }
        }

        fetchSignals();
        // Polling logic removed for now to prevent spamming if hanging
        // const interval = setInterval(fetchSignals, 10000);
        // return () => clearInterval(interval);
        return () => controller.abort();
    }, []);

    // Filter signals for PerformanceStats (Specific to active channel)
    // Note: SignalTable does its own filtering for display, but Stats needs explicit subset
    const channelSignals = signals.filter(s => (s.channel_name || "Unknown") === activeChannel);

    return (
        <div className="min-h-screen bg-background flex flex-col">
            <header className="border-b border-border p-4">
                <div className="container mx-auto flex items-center gap-4">
                    <Link href="/" className="text-muted-foreground hover:text-foreground transition-colors">
                        <ArrowLeft className="w-5 h-5" />
                    </Link>
                    <h1 className="text-xl font-bold text-foreground">Live Performance Log</h1>
                </div>
            </header>

            <main className="flex-1 container mx-auto p-4 md:p-8 space-y-8">
                <div className="space-y-2">
                    <h2 className="text-3xl font-bold tracking-tight">Signal History</h2>
                    <p className="text-muted-foreground">
                        Real-time log of all signals generated by our automated system.
                    </p>
                </div>

                {/* Using new dynamic PerformanceStats */}
                <PerformanceStats signals={channelSignals} activeChannel={activeChannel} />

                {/* SignalTable with controlled state */}
                <SignalTable
                    signals={signals}
                    activeChannel={activeChannel}
                    onChannelChange={setActiveChannel}
                    isLoading={loading}
                />
            </main>
        </div>
    );
}
